      SUBROUTINE DisOrder(InfoFile,NAtoms,NASym,
     >                    NPrim,NCtrt,NKind,NShells,NTypes,
     >                    LenDis,LenPrm,NCnts,LMNLen,LMNLen2,
     >                    CDrv,NCFuncs,NPFuncs,AngSym,BasFPerKind,
     >                    AtomType,LxDex,LyDex,LzDex,
     >                    LStart,LStop,DisPtr,BufT,BufN,
     >                    MXDis,MXPrm,
     >                    WK,CD,WR,WZ,W1,W2,
     >                    CCode,TCode,TCPop,AC2Test,
     >                    DistNeglect,Exponent,CCoefcnt,Carts,
     >                    DisBuf,PrmBuf,TmpBufP,TmpBufC,SchT)
      IMPLICIT REAL*8 (a-h,o-z)
      IMPLICIT INTEGER (i-n)
      INCLUDE 'pmsonx.inc'
      REAL*8  Exponent(NPrim,NCtrt,NKind)
      REAL*8  CCoefcnt(LMNLen,NPrim,NCtrt,NKind)
      REAL*8  Carts(3,NAtoms)
      REAL*8  TmpBufP(MXP,NPrim*NPrim+MInfo,MXD)
      REAL*8  TmpBufC(MXC,MXD)
      REAL*8  SchT(MXD,NTypes,NPrim*NPrim)
      REAL*8  DisBuf(MXDis)
      REAL*8  PrmBuf(MXPrm)

      REAL*8  WK(4,NPrim**2)
      REAL*8  CD(NPrim**2,3)
      REAL*8  WR(6,NPrim**4)
      REAL*8  WZ(3,NPrim**4)
      REAL*8  W1(MXINT)
      REAL*8  W2(MXINT)
      INTEGER CDrv(60000)
      INTEGER MLDis(1)
      INTEGER iT(6,6)

      INTEGER TCode(MXTC)
      INTEGER CCode(MXCC)
      INTEGER TCPop(MXTC,MXCC)
      INTEGER DisPtr(3,NShells,NTypes,NPrim*NPrim)
      INTEGER BufT(MXD,NTypes,NPrim*NPrim)
      INTEGER BufN(NTypes,NPrim*NPrim)
      INTEGER NCFuncs(NKind)
      INTEGER NPFuncs(NCtrt,NKind)
      INTEGER AngSym(2,NCtrt,NKind)
      INTEGER BasFPerKind(NKind)
      INTEGER AtomType(NAtoms)
      INTEGER LxDex(LMNLen)
      INTEGER LyDex(LMNLen)
      INTEGER LzDex(LMNLen)
      INTEGER LStart(NCtrt,NKind)
      INTEGER LStop(NCtrt,NKind)
      INTEGER CType
      INTEGER CFA,PFA,StartLA,StopLA,StrideA
      INTEGER CFC,PFC,StartLC,StopLC,StrideC
      CHARACTER*128 InfoFile
      INCLUDE "bksonx.inc"
      DATA iT/ 1, 0, 0, 0, 0, 0,
     $         2, 3, 0, 0, 0, 0,
     $         4, 5, 6, 0, 0, 0,
     $         0, 0, 0, 0, 0, 0,
     $         0, 0, 0, 0, 0, 0,
     $         7, 8, 9, 0, 0, 10 /


      CALL ILoader(TCPop,MXTC*MXCC,0)
      CALL ILoader(DisPtr,3*NShells*NTypes*NPrim*NPrim,0)

      CALL MondoIO('O',' ',' '       ,InfoFile,0,0D0,' ',0)
      CALL MondoIO('R','I','ncfuncs' ,InfoFile,NCFuncs,0D0,' ',NKind)
      CALL MondoIO('R','I','angsym'  ,InfoFile,AngSym,0D0,' ',
     >                                2*NCtrt*NKind)
      CALL MondoIO('R','I','npfuncs' ,InfoFile,NPFuncs,0D0,' ',
     >                                NCtrt*NKind)
      CALL MondoIO('R','R','ccoefcnt',InfoFile,0,CCoefcnt,' ',
     >                                LMNLen*NPrim*NCtrt*NKind)
      CALL MondoIO('R','R','exponent',InfoFile,0,Exponent,' ',
     >                                NPrim*NCtrt*NKind)
      CALL MondoIO('R','I','atomtype',InfoFile,AtomType,0D0,' ',NAtoms)
      CALL MondoIO('C',' ',' '       ,InfoFile,0,0D0,' ',0)

      CALL LoopIndexes(NKind,NCtrt,NASym,LMNLen,NCFuncs,AngSym,
     >                 LxDex,LyDex,LzDex,LStart,LStop,BasFPerKind)

      CALL CCDriver(CDrv,LngDrv)

      MLDis(1)=1
      Prev = DSQRT(2.0D0*rPi**(5.0D0/2.0D0))
      LenCC=0
      LenTC=0
      iPrm=1
      iDis=1
      IndexA=0
      DO 8500 AtA=1,NAtoms
         Ax=Carts(1,AtA)
         Ay=Carts(2,AtA)
         Az=Carts(3,AtA)
         KA=AtomType(AtA)
         DO 8000 CFA=1,NCFuncs(KA)
            IndexA=IndexA+1
            StartLA= LStart(CFA,KA)
            StopLA = LStop(CFA,KA)
            StrideA=StopLA-StartLA+1
            MinLA=AngSym(1,CFA,KA)
            MaxLA=AngSym(2,CFA,KA)
            IType=MaxLA*(MaxLA+1)/2+MinLA+1
            NICase=MaxLA-MinLA+1
            KonA=NPFuncs(CFA,KA)

      CALL ILoader(BufN,NTypes*NPrim*NPrim,0)
      iB=1
      IndexC=0

      DO 7500 AtC=1,NAtoms
         Cx=Carts(1,AtC)
         Cy=Carts(2,AtC)
         Cz=Carts(3,AtC)
         ACx=Ax-Cx
         ACy=Ay-Cy
         ACz=Az-Cz
         AC2=ACx*ACx+ACy*ACy+ACz*ACz
         KC=AtomType(AtC)
         IF(AC2.GT.AC2Test) THEN
            IndexC=IndexC+NCFuncs(KC)
            GOTO 7300
         ENDIF

         DO 7000 CFC=1,NCFuncs(KC)
            IndexC=IndexC+1
            StartLC= LStart(CFC,KC)
            StopLC = LStop(CFC,KC)
            StrideC=StopLC-StartLC+1
            MinLC=AngSym(1,CFC,KC)
            MaxLC=AngSym(2,CFC,KC)
            KType=MaxLC*(MaxLC+1)/2+MinLC+1
            NKCase=MaxLC-MinLC+1
            CType=(MaxLA-MinLA+1)*10+(MaxLC-MinLC+1)
            KonC=NPFuncs(CFC,KC)
            II=MAX(IndexA,IndexC)
            JJ=MIN(IndexA,IndexC)
            IJ=II*(II-1)/2+JJ
            TmpBufC(1,iB)=DFLOAT(IJ)+Small
            TmpBufC(2,iB)=DFLOAT(IndexC)+Small
            IF(IType.GE.KType) THEN
               IKType=IType*100+KType
               TmpBufC( 3,iB)=DFLOAT(IndexA)+Small
               TmpBufC( 4,iB)=DFLOAT(IndexC)+Small
               TmpBufC( 5,iB)=ACx
               TmpBufC( 6,iB)=ACy
               TmpBufC( 7,iB)=ACz
               TmpBufC( 8,iB)=Ax
               TmpBufC( 9,iB)=Ay
               TmpBufC(10,iB)=Az
            ELSE
               IKType=KType*100+IType
               TmpBufC( 3,iB)=DFLOAT(IndexC)+Small
               TmpBufC( 4,iB)=DFLOAT(IndexA)+Small
               TmpBufC( 5,iB)=-ACx
               TmpBufC( 6,iB)=-ACy
               TmpBufC( 7,iB)=-ACz
               TmpBufC( 8,iB)=Cx
               TmpBufC( 9,iB)=Cy
               TmpBufC(10,iB)=Cz
            ENDIF

      I0=0
      DO 2000 PFA=1,NPFuncs(CFA,KA)
         Za=Exponent(PFA,CFA,KA)
         DO 1000 PFC=1,NPFuncs(CFC,KC)
            Zc=Exponent(PFC,CFC,KC)
            Zeta=Za+Zc
            r1xZ=1.0D0/Zeta
            Px  = (Za*Ax+Zc*Cx)*r1xZ
            Py  = (Za*Ay+Zc*Cy)*r1xZ
            Pz  = (Za*Az+Zc*Cz)*r1xZ
            Cnt = CCoefcnt(StopLA,PFA,CFA,KA)*
     >            CCoefcnt(StopLC,PFC,CFC,KC)
            VSAC=DEXP(-Za*Zc*r1xZ*AC2)*Cnt*r1xZ*Prev
            IF(ABS(VSAC).GT.DistNeglect) THEN
               I0=I0+1
               TmpBufP(1,I0,iB)=Zeta
               TmpBufP(2,I0,iB)=Px
               TmpBufP(3,I0,iB)=Py
               TmpBufP(4,I0,iB)=Pz
               TmpBufP(5,I0,iB)=VSAC
               IF(CType.EQ.11) THEN
                  TmpBufP(6,I0,iB)=1.0D0
                  TmpBufP(7,I0,iB)=1.0D0
                  TmpBufP(8,I0,iB)=1.0D0
               ELSEIF(CType.EQ.12.OR.CType.EQ.21) THEN
                  TmpBufP(6,I0,iB)=CCoefcnt(StartLA,PFA,CFA,KA)*
     >                             CCoefcnt(StartLC,PFC,CFC,KC)/Cnt
                  TmpBufP(7,I0,iB)=TmpBufP(6,I0,iB)
                  TmpBufP(8,I0,iB)=TmpBufP(6,I0,iB)
               ELSEIF(CType.EQ.22) THEN
                  TmpBufP(6,I0,iB)=CCoefcnt(StartLA,PFA,CFA,KA)*
     >                             CCoefcnt(StartLC,PFC,CFC,KC)/Cnt
                  TmpBufP(7,I0,iB)=CCoefcnt(StartLA+1,PFA,CFA,KA)*
     >                             CCoefcnt(StartLC,PFC,CFC,KC)/Cnt
                  TmpBufP(8,I0,iB)=CCoefcnt(StartLA,PFA,CFA,KA)*
     >                             CCoefcnt(StartLC+1,PFC,CFC,KC)/Cnt
               ELSE
                  WRITE(*,*) "CType=",CType
                  CALL MondoHalt(' Illegal CType in DisOrder')
               ENDIF
c               TmpBufP(9,I0,iB)=ABS(TmpBufP(5,I0,iB))
            ENDIF
 1000    CONTINUE
 2000 CONTINUE
      IF(I0.EQ.0) GOTO 6900
c
c Compute the ERI estimates
c
      KonAC=I0
      LDis=MaxLA+MaxLC
      Ltot=2*LDis
      NLOCD2=IDmn(LDis)
      NLOCD3=NFinal(IType)*NFinal(KType)
      NInts=NLOCD3*NLOCD3
      I0=iT(MIN(IType,KType),MAX(IType,KType))
      I1=11*I0-10
      iCP=CDrv(I1)
      iCL=CDrv(iCP)

      CALL RGen1C(Ltot,KonAC,WK,CD,WR,WZ,W1,
     >            TmpBufP(1,1,iB),TmpBufC(1,iB))

      CALL VRRg(1,KonAC,KonAC,LDis,LDis,NLOCD2,NLOCD2,
     >          WR,WZ,WK,TmpBufP(1,1,iB),W2,W1)

      CALL Contract(1,KonAC,KonAC,iCL,CDrv(iCP+1),
     >              CD,CD,W1,W2)

      IF(LDis.NE.0) THEN
         CALL HRRKetOld(1,IKType,NLOCD2,MXC,MLDis,TmpBufC(1,iB),W1)
         CALL HRRBraOld(1,IKType,NLOCD2,NLOCD3,NLOCD3,W1,W2)
         CALL GetBigInt(NInts,rInt,W2)
      ELSE
         CALL GetBigInt(NInts,rInt,W1)
      ENDIF

      TmpBufC(11,iB)=rInt

      IF(rInt.GT.DistNeglect) THEN
c         CALL SortPrims(KonAC,TmpBufP(1,1,iB),TmpBufP(1,1,iB+1))
         iB=iB+1
         IF(iB.GT.MXD) CALL MondoHalt('MXD too small in SONX')
         DO I=1,LenCC
            IF(KonAC.EQ.CCode(I)) THEN
               iKonAC=I
               GOTO 3000
            ENDIF
         ENDDO
         LenCC=LenCC+1
         iKonAC=LenCC
         IF(LenCC.GT.MXCC)
     >      CALL MondoHalt('MXCC to small in SONX')
         CCode(LenCC)=KonAC
 3000    CONTINUE
         DO I=1,LenTC
            IF(IKType.EQ.TCode(I)) THEN
               iIKType=I
               GOTO 4000
            ENDIF
         ENDDO
         LenTC=LenTC+1
         iIKType=LenTC
         IF(LenTC.GT.MXTC)
     >      CALL MondoHalt('MXTC too small in SONX')
         TCode(LenTC)=IKType
 4000    CONTINUE
         BufN(iIKType,iKonAC)=BufN(iIKType,iKonAC)+1
         Lng=BufN(iIKType,iKonAC)
         IF(Lng.GT.MXD) CALL MondoHalt('MXD too small in SONX')
         BufT(Lng,iIKType,iKonAC)=iB-1
         SchT(Lng,iIKType,iKonAC)=rInt
      ENDIF

 6900    CONTINUE
 7000    CONTINUE
 7300    CONTINUE
 7500 CONTINUE

c
c Do the sorting stuff here.
c

      DO I=1,LenCC
         DO J=1,NTypes
            KonAC=CCode(I)
            IKType=TCode(J)
            N=BufN(J,I)
            IF(N.GT.0) THEN
               TCPop(J,I)=1
               IF(iDis+N*MXC.GT.MXDis) 
     >            CALL MondoHalt('5:Out of memory in SONX')
               IF(iPrm+N*(KonAC+MInfo)*MXP.GT.MXPrm) 
     >            CALL MondoHalt('6:Out of memory in SONX')
               CALL QuickSortDis(SchT(1,J,I),BufT(1,J,I),N,-2)
               DisPtr(1,IndexA,J,I)=N
               DisPtr(2,IndexA,J,I)=iDis
               DisPtr(3,IndexA,J,I)=iPrm
               CALL PutDis(N,NPrim,iDis,iPrm,KonAC,
     >                     BufT(1,J,I),
     >                     TmpBufP,TmpBufC,
     >                     DisBuf(iDis),PrmBuf(iPrm))

            ENDIF
         ENDDO
      ENDDO

 8000    CONTINUE
 8500 CONTINUE

      LenDis = iDis - 1
      LenPrm = iPrm - 1
      NCnts  = LenCC


      RETURN
      END
